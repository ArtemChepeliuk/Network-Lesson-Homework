1. Список відмінностей між HTTP 1.0 і 1.1
      Зміни для спрощення багатоядерних веб-серверів та збереження IP-адрес
         Адреси
Вимоги, що клієнти та сервери підтримують заголовок запиту Host, повідомляють про помилку, якщо хост запиту хоста відсутній у запиті HTTP / 1.1 та прийняття абсолютних URI є одним з найважливіших зміни, визначені цією специфікацією.

Більш старі клієнти HTTP / 1.0 прийшли до взаємовідносин IP-адрес та серверів; не існувало іншого встановленого механізму для розмежування призначеного сервера запиту, ніж IP-адреса, на яку був спрямований цей запит. Зміни, викладені вище, дозволять Інтернет, коли колись старі HTTP-клієнти більше не є загальними, підтримувати кілька веб-сайтів з однієї IP-адреси, значно спрощуючи великі операційні веб-сервери, де виділення багатьох IP-адрес для одного хоста викликало серйозні проблеми . Інтернет також зможе відновити IP-адреси, які були виділені з єдиною метою - дозволити використання спеціальних доменних імен у URL-адресах HTTP на рівні кореневого рівня. Враховуючи темпи зростання веб-сайтів та кількість серверів, які вже розгорнуті, це надзвичайно важливо

Важливо, що всі реалізації HTTP (включаючи оновлення наявних додатків HTTP / 1.0) правильно виконують ці вимоги:

      - І клієнти, і сервери ПОВИННІ підтримувати заголовок запиту хоста.
      - Клієнт, який надсилає запит HTTP / 1.1, повинен надсилати заголовок Host.
      - Сервери ПОВИННІ повідомити про помилку 400 (поганий запит), якщо запит HTTP / 1.1 
        не включає заголовок запиту хоста.
      - Сервери ПОВИННІ приймати абсолютні URI.
Сумісність із стійкими підключеннями HTTP / 1.0
Деякі клієнти та сервери, можливо, прагнуть бути сумісними з деякими попередніми реалізаціями постійних з'єднань у клієнтах і серверах HTTP / 1.0. Постійні з'єднання в HTTP / 1.0 явно узгоджуються, оскільки вони не є поведінкою за умовчанням. HTTP / 1.0 експериментальні реалізації постійних з'єднань несправні, а нові об'єкти в HTTP / 1.1 розроблені для виправлення цих проблем. Проблема полягала в тому, що деякі існуючі 1,0клієнти можуть надсилати Keep-Alive на проксі-сервер, який не розуміє Connection, який потім помилково передав його на наступний вхідний сервер, який встановив зв'язок Keep-Alive і призведе до виклику проксі HTTP / 1.0, який чекає на закрийте відповідь. Результат полягає в тому, що під час розмови з проксі-серверами HTTP / 1.0 клієнти не повинні використовувати Keep-Alive.

Проте розмова з проксі-серверами є найважливішим використанням постійних з'єднань, тому заборона явно неприйнятна. Тому нам потрібен якийсь інший механізм для вказівки на постійне з'єднання, яке можна використовувати навіть під час розмови з старим проксі-сервером, який ігнорує підключення. Постійні з'єднання є типовими для HTTP / 1.1 повідомлень; ми вводять нове ключове слово (Connection: close), щоб оголосити про непостійність. .

 Зміни з RFC 2068
Ця специфікація була ретельно перевірена для виправлення та неоднозначного використання ключових слів; RFC 2068 мав багато проблем у конвенціях, викладених в RFC 2119.

Пояснити, який код помилки слід використовувати для збоїв вхідних серверів (наприклад, DNS-збоїв).

CREATE мала расу, яка вимагала відправки Etag, коли ресурс був створений першим. (Розділ 10.2.2).

Content-Base була вилучена з специфікації: вона не була широко впроваджена, і не існує простих та безпечних способів її введення без надійного механізму розширення. Крім того, вона використовується в аналогічній, але не ідентичній формі в MHTML  .

Передача-кодування та довжини повідомлень взаємодіють між собою так, що це вимагає фіксування, коли використовується кодована кодування (щоб забезпечити кодування передачі, яке не може бути саморозмітним); було важливо точно вирівняти, як обчислюються довжини повідомлення. (Розділи 3.6 , 4.4 , 7.2.2 , 13.5.2 , 14.13 , 14.16 )

Впроваджено контент-кодування "ідентичності" для вирішення проблем, виявлених при кешування. (розділ 3.5)

Якісні значення нуля повинні вказувати на те, що "Я не хочу щось", щоб дозволити клієнтам відмовитися від представництва. (Розділ 3.9)

Використання та інтерпретація номерів версій HTTP було роз'яснено RFC 2145. Вимагати проксі для оновлення запитів до найвищої версії протоколу, яку вони підтримують для вирішення проблем, виявлених у реалізації HTTP / 1.0 (розділ 3.1 ).

Введено підстановки символів "Charset", щоб уникнути вибуху наборів символів у приймальних заголовках. (Розділ 14.2)

У моделі Cache-Control HTTP / 1.1 була відсутня справа; s-maxage був введений, щоб додати цей недолік. (Розділи 13.4, 14.8, 14.9, 14.9.3 )

Кеш-Контроль: директива max-age не визначено належним чином для відповідей. (Розділ 14.9.3)

Існують ситуації, коли сервер (особливо проксі-сервер) не знає повної довжини відповіді, але здатний обслуговувати запит, що поступається. Отже, нам потрібен механізм, який дозволяє переходити до діапазону вмісту, який не вказує повну довжину повідомлення. (Розділ 14.16 )

Відповіді на запити діапазону стануть дуже багатослівними, якщо всі мета-дані завжди повертаються; дозволяючи серверу надсилати лише необхідні заголовки у відповідь 206, цю проблему можна уникнути. (Розділ 10.2.7 , 13.5.3 та 14.27 )

Виправлення проблеми з незадовільними запитами діапазону; Є два випадки: синтаксичні проблеми, а діапазон не існує в документі. Код стану 416 був потрібний для вирішення цієї неоднозначності, необхідної для позначення помилки для запиту діапазону байтів, який виходить за межі фактичного вмісту документа. (Розділ 10.4.17 , 14.16 )

Переписати вимоги щодо передачі повідомлень, щоб зробити його набагато важчим, оскільки його помилки можуть мати значний вплив на Інтернет та вирішити такі проблеми:

      1. Зміна "HTTP / 1.1 або пізнішої" на "HTTP / 1.1", в контекстах, де 
         це було неправильно, вимоги до поведінки 
         реалізації майбутньої версії HTTP / 1.x
      2. Зрозуміло, що користувацькі агенти повинні повторити спроби, а не 
         "клієнти" взагалі.
      3. Перетворені вимоги для клієнтів, щоб ігнорувати несподівані 100 
         (Продовжити) відповіді, а також проксі, щоб переслати 100 відповідей, 
         в загальну вимогу для 1хх відповідей.
      4. Модифікована деяка TCP-мова, щоб зрозуміти, що 
         для HTTP можливі перевезення поза TCP.
      5. Вимагати, щоб сервер-джерело НЕ ПОВИНЕН чекати 
         тіла запиту, перш ніж надсилати необхідну 100 (Продовжити) відповідь.
      6. Дозвольте, а не вимагати, серверу пропустити 100 (Продовжити), якщо 
         він вже побачив частину тіла запиту.
      7. Дозволити серверам захищатись від атак на відмову в обслуговуванні та 
         зламаних клієнтів.
Ця зміна додає заголовок Expect і код статусу 417. Виправлення вимог щодо передачі повідомлень наведено в розділах 8.2, 10.4.18, 8.1.2.2 , 13.11 та 14.20 .

Прокси повинні мати можливість додавати Content-Length, коли це доречно. (Розділ 13.5.2)

Очистіть плутанину між 403 і 404 відповідями. (Розділи 10.4.4 , 10.4.5 та 10.4.11)

Попередження можуть бути кешовані неправильно або не оновлюються належним чином. (Розділ 13.1.2, 13.2.4, 13.5.2, 13.5.3, 14.9.3 та 14.46) Попередження також повинні бути загальним заголовком, оскільки в запитах може знадобитися PUT або інші методи.

Передача-кодування мав значні проблеми, особливо з взаємодією з кодуванням. Рішення полягає в тому, що кодування передачі стають повноцінними як контент-кодування. Це передбачає додавання реєстру IANA для кодування передач (окремо від кодування вмісту), нового поля заголовка (TE) та включення заголовків трейлера в майбутньому. Передача кодування - це головна перевага продуктивності, тому варто було це виправити. ТЕ також вирішує іншу проблему сумісності, яка могла статися через взаємодію між прив'язками автентифікації, кодуванням кодувань та клієнтами HTTP / 1.0 (розділ 3.6 , 3.6.1 та 14.39 ).

Методи PATCH, LINK, UNLINK були визначені, але не були загальноприйнятими в попередніх версіях цієї специфікації. 

Поля заголовків альтернатив, контент-версії, похідних від, посилань, URI, загальнодоступних і зміст-база були визначені в попередніх версіях цієї специфікації, але не зазвичай реалізовані.





2. How to pass user-data via GET? via POST? what is the diff?
GET - запитує дані з вказаного ресурсу
POST - передає дані для обробки на вказаний ресурс

Різниця між методом GET i POST в тому що GET не може передавати великий об'єм інформації, метод GET не використовується  для передачі особистих даних.

3. Few samples of websites (and cases) where POST method is used

- https://fiddle.jshell.net/_display/ POST використувується коли натиснути кнопку RUN, щоб відобразити згенерований код.
- https://api.privatbank.ua/stat - напевне використовується для збору якоїсь статистики.
- https://play.google.com/log?format=json&authuser=0 - коли натискаєш кнопку на картинці гугл то він запускає мультик.
